# 1. 상속

## 상속의 정의와 장점

상속의 정의
> 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것

상속의 장점
> 보다 적은 양의 코드로 새로운 클래스를 작성할 수 있고, 코드를 공통적으로 관리할 수 있기 때문에 코드의 추가 및 변경에 매우 용이하다.

- 코드 재사용성을 높임
- 코드의 중복을 제거하여 생산성과 유지보수에 크게 기여함



![image](https://user-images.githubusercontent.com/53935439/208241149-0a517d72-4f56-4f4f-ae2f-42d6ac349afd.png)

조상 클래스
>상속해주는 클래스
- 부모 클래스
- 상위 클래스
- 기반 클래스

자손 클래스
>상속 받는 클래스
- 자식 클래스
- 하위 클래스
- 파생된 클래스

상속관계를 그림으로 표현한 것을 "상속계층도"라고하며 아래와 같이 표현한다.

![image](https://user-images.githubusercontent.com/53935439/208241523-d7140967-e027-432e-b727-b282fca8b4c6.png)

상속 관계의 특징은 아래와 같다.
- 생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
- 자손 클래스의 멤버 개수는 조상 클래스보다 항상 같거나 많다.

그렇다면 만약 자손 클래스의 인스턴스를 생성하면 어떻게 될까? 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버도 함께 생성된다.
때문에 조상 클래스의 인스턴스를 생성하지 않고도 조상 클래스의 멤버들을 사용할 수 있다.

> 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.

## 클래스간의 관계

상속 이외에도 클래스를 재사용하는 방법이 있는데 그것은 바로 클래스간에 포함 관계를 맺어주는 것이다.
클래스 간의 포함관계를 맺어 주는 것은 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것을 뜻한다.

```java
class Circle{
    Point c = new Point();
    int r;
}
```

이런식으로 클래스를 멤버변수로 선언하여 포함관계를 맺어주면 작성하는 것도 쉽고 간결해서 이해하기 쉽다.
또한 단위클래스 별로 코드가 작게 나뉘에 작성되어 있기 때문에 코드를 관리하는데도 수월하다.

## 클래스간의 관계 결정하기

클래스를 작성하는데 있어서 상속관계를 맺어 줄 것인지 포함관계를 맺어 줄 것인지 결정하는 것은 때떄로 혼돈스러울 수 있다.

이럴 때는 아래와 같이 문장을 만들어 보면 클래스 간의 관계가 보다 명확해 진다.

상속관계
> Circle은 Point이다

포함관계
> Circle은 Point를 가지고 있다.

예를 들어 도형을 의미하는 Shape 클래스를 정의하고 Circle 클래스와 관계를 맺어준다면
> 원은 도형이다 (O) 원은 도형을 가지고 있다 (X)

라는 의미가 좀 더 자연스러울 것이다.

## 단일 상속

다른 객체지향언어와 다르게 자바에서는 오직 단일 상속만을 허용한다. 때문에 둘 이상의 클래스로부터 상속을 받을 수 없다.

다중상속을 허용하면 여러 클래스로부터 상속받을 수 있기 때문에 복합적인 기능을 갖을 수는 있지만 아래와 같은 단점들이 있다.

- 클래스간의 관계가 매우 복잡해짐
- 서로 다른 클래스로부터 상속 받은 멤버의 이름이 같을 경우 구분할 수 있는 방법이 없음

때문에 클래스간의 관계를 보다 명확히 하고 코드를 더욱 신뢰할 수 있게 만들어주기 위해 단일 상속만을 허용한다.



## Object 클래스

Object 클래스는 모든 클래스 상속계층도의 최상위에 있는 조상 클래스이다. 다른 클래스로부터 상속 받지 않는 모든 클래스는
컴파일러가 자동으로 Object클래스로부터 상속받게 함으로써 이것을 가능하게 한다.

그렇기 떄문에 모든 클래스에서는 Object 클래스에 정의된 멤버들을 사용할 수 있는데
우리가 toString(), equals() 같은 메서드를 따로 정의하지 않고도 사용할 수 있었던 이유가 바로 이것이다.

# 2. 오버라이딩

## 오버라이딩이란

>조상 클래스로부터 상속 받은 메서드의 내용을 변경하는 것

## 오러라이딩의 조건

자손 클래스에서 오버라이딩하는 메서드는 조상 클래스의 메서드와
- 이름이 같아야한다.
- 매개변수가 같아야한다.
- 반환타입이 같아야한다.

즉, 한마디로 요약하자면 선언부가 서로 일치해야한다.

다만 접근 제어자와 예외는 제한된 조건 하에서만 다르게 변경할 수 있다.

조상 클래스의 메서드를 오버라이딩 할 때 주의사항
- 접근 제어자를 조상 클래스의 메서드보다 좁은 범위로 변경할 수 없다.
- 예외는 조상 클래스의 메서드보다 많이 선언할 수 없다.
- 인스턴스 메서드를 static 메서드 또는 그 반대로 변경할 수 없다.

## super

> 자손 클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수

멤버 변수와 지역 변수의 이름이 같을 때, this를 통해 구분했듯이 상속받은 멤버와 자신의 멤버와 이름이 같을 때는
super를 붙여서 구분할 수 있다.

```java
class Parent{
    int x = 20;
}
class Child extends Parent{
    int x = 10;
    void method(){
        System.out.println(this.x); // 10
        System.out.prinltn(super.x); // 20
    }
}
class Ex{
    public static void main(String[] args) {
        Child c = new Child();
        c.method();
        
        /*
         * 10
         * 20
         * */
    }
}
```

## super() - 조상 클래스의 생성자

this()와 마찬가지로 super() 역시 생성자이다. this()의 경우 같은 클래스의 다른 생성자를 호출하는데 사용되지만

super()는
> 조상 클래스의 생성자를 호출하는데 사용된다.

자손 클래스의 인스턴스를 생성하면 자손 멤버와 조상 멤버가 모두 합쳐진 하나의 인스턴스가 생성된다. 이 때 조상 클래스 멤버의 초기화 작업이 수행되어야 하기 때문에
자손 클래스의 생성자에서 조상 클래스의 생성자가 호출되어야 한다.

**생성자의 첫 줄에서 조상 클래스의 생성자를 호출**해야 하는 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수도 있으므로 먼저 조상 클래스 멤버들이 초기화되어 있어야 하기 때문이다.

이와 같은 조상 클래스 생성자의 호출은 클래스의 상속관계를 거슬러 올라가면서 계속 반복되며 Object 클래스의 생성자까지 가서야 끝이난다.

그래서 Object 클래스를 제외한 모든 클래스의 생성자는 첫 줄에 반드시 자신의 다른 생성자 또는 조상의 생성자를 호출해야 한다.

그렇지 않으면 컴파일러는 생성자의 첫 줄에 super(); 를 자동으로 추가할 것이다.

# 3. package와 import

## 패키지

> 클래스의 묶음

서로 관련된 클래스들끼리 그룹 단위로 묶어 놓음으로써 클래스를 효율적으로 관리할 수 있다.


## import 문

소스코드를 작성할 때 다른 패키지의 클래스를 사용하려면 패키지명이 포함된 클래스 이름을 사용해야된다.

하지만 매번 그렇게 작성하는 것은 불편하다..

> 클래스의 코드를 작성하기 전에 import 문으로 사용하고자 하는 클래스의 패키지를 미리 명시해주면 소스코드에 사용되는 클래스 이름에서 패키지 명은 생략할 수 있다.

## import 문의 선언

- import 패키지명.클래스명
- import 패키지명

하나 더 알아두어야 할 것은 import 패키지명.* 을 하는 경우를 흔히 볼 수 있는데, 이는 해당 패키지에서 일치하는 수고를 덜어주며
> 실행 시 성능차이는 전혀 없다


## static import 문

> static 멤버를 호출할 때 클래스 이름을 생략할 수 있다.

특정 클래스의 static 멤버를 자주 사용할 때 편리하며 코드도 간결해 진다.

# 4. 제어자 ( modifier )

## 제어자란?

제어자는
> 클래스, 변수 또는 메서드의 선언부와 함께 사용되어 부가적인 의미를 부여한다.

제어자의 종류는 크게 접근 제어자와 그 외의 제어자로 나눌 수 있다.
- 접근 제어자
    - public, protected, default, private
- 그외
    - static, final, abstract, native, transient, synchronized, volatile, strictfp

주로 클래스나 멤버변수, 메서드에 사용되며 하나의 대상에 대해서 여러 제어자를 조합하여 사용하는 것이 가능하다.

단, 접근제어자의 경우 하나만 선택가능

## static - 클래스의, 공통적인

static 은 멤버 변수, 메서드 그리고 초기화 블럭에서 사용되며, 이들은 클래스에 관계된 것이기 때문에
> 인스턴스를 생성하지 않고도 사용할 수 있다.

인스턴스 메서드와 static 메서드의 근본적인 차이는 인스턴스 멤버를 사용하는가의 여부에 있다.
따라서 인스턴스 멤버를 사용하지 않는 메서드는 static 을 붙여서 static 메서드로 선언하는 것이 좋은데 이유는
> 인스턴스를 생성하지 않고도 호출이 가능해서 더 편리하고 속도도 빠르다.

```java
class Ex{
    static int x = 0;
    static {
        // static 변수의 복잡한 초기화 수행
    }
    static int max(int a, int b){
        return a > b ? a : b;
    }
}
```

## final - 마지막의, 변경될 수 없는


변수에 사용되면 값을 변경할 수 없는 상수가 되며
메서드에 사용되면 오버라이딩을 할 수 없게 되고
클래스에 사용되면 자신을 확장하는 자손클래스를 정의하지 못하게 된다.

> 즉, 변경될 수 없어진다.

```java
final class Ex { // 자손 클래스 생성 불가능
    final int MAX_VALUE = 10; // 값 변경 불가능
    final void getMaxSize(){ // 오버라이딩 불가능
        return MAX_VALUE;
    }
}
```

## abstract - 추상의, 미완성의

메서드의 선언부만 작성하고 실제 수행내용은 구현하지 않은 추상 메서드를 선언하는데 사용된다.

또한 클래스에 사용되어 클래스 내에 추상메서드가 존재한다는 것을 쉽게 알 수 있게 한다.

> 클래스, 메서드에 사용될 수 있음

드물지만 추상 메서드가 존재하지 않는 클래스에 사용되는 경우도 있는데, 이는 인스턴스 생성을 제한하는 용도로 사용된다.
해당 클래스 자체로는 쓸모가 없지만 일부 메서드를 오버라이딩 해야할 때 사용된다.

## 접근 제어자

멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.

접근 범위
- private : 클래스 내
- default : 패키지 내
- protected : 패키지 내 + 자손 클래스
- public : 전체

접근 제어자를 사용하는 이유는 다음과 같다. - 캡슐화
- 외부로부터 데이터를 보호
- 외부로부터 데이터를 숨김으로써 복잡성을 줄임

예를 들어 public 으로 선언된 메서드를 수정한다고 생각해보면 오류 테스트 범위가 넓다. 즉 수정해야 할 범위가 넓다..
하지만 private 으로 선언된 메서드를 수정한다고 생각해보면 클래스 하나만 살펴보면 된다.
이렇듯 복잡성을 줄여줄 수 있으므로 접근 제어자를 적절히 선택해서 접근 범위를 최소화하도록 노력해야한다.

### +@ 생성자 private

생성자에 private으로 지정하면 외부에서 인스턴스 생성을 제한할 수 있는데, 이를 이용하여 public 메서드를 통해 인스턴스에 접근하도록 만들어 인스턴스 개수를 제한하는 싱글톤 패턴 등에 사용되기도 한다.

또한 private 으로 생성자를 만들면 해당 클래스는 상속받을 수 없게 되므로 (자손 클래스에서 생성자 호출 불가능) class 에 final 을 붙여 명시적으로 표현해주는 것이 좋다.

# 5. 다형성

## 다형성이란

상속과 함께 객체지향개념의 중요한 특징 중 하나로
> 여러가지 형태를 가질 수 있는 능력을 의미한다.

자바에서는 한 타입의 참조변수로 여러 타입의 객체를 참조할 수 있도록 하여 다형성을 프로그래밍적으로 구현하였고

이를 좀 더 구체적으로 말하자면
> 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할 수 있도록 한 것이다.

먼저 알아두어야 할 것은 아래와 같다.
- 조상클래스 타입의 참조변수로 자손클래스 인스턴스를 참조하게 되면 자손 클래스에서 추가된 멤버들을 사용할 수 없다.
- 자손 클래스 타입의 참조변수는 조상클래스의 인스턴스를 참조할 수 없다. (당연히.. 자손클래스에 있지만 조상클래스에는 없는 것에 접근할 수 있게 되므로)

## 참조변수의 형변환

참조변수도 형변환이 가능하다. 단, 서로 **상속관계**에 있는 클래스 사이에서만 가능하며
- 자손타입 -> 조상타입 (Up-casting) : 형변환 생략 가능
- 조상타입 -> 자손타입 (Down-casting) : 형변환 생략 불가능

이렇게 두 가지 모두 가능하다.

주의해야 할 것은 다운캐스팅할 때에는 캐스트연산자를 붙여주어야 한다는 것이다.

````java
class Car{
    void drive(){}
}
class BMW extends Car{
    void autoDrive(){};
}
class Ex{
  public static void main(String[] args) {
    Car c = null;
    Bmw bmw = new Bmw();
    Bmw bmw2 = null;
    
    c = bmw; // 다형성.. 업캐스팅
    bmw2 = (Bmw)c; // 다운캐스팅
    
  }
}
````

다운캐스팅 시에 캐스트 연산자를 생략할 수 없는 이유는 자손클래스의 참조변수가 접근할 수 있는 멤버의 범위가 늘어나는 것이므로 자손클래스로 캐스트연산자로 형변환을 시켜 해당 인스턴스에서 사용할 수 있는 멤버의 범위를 늘려주어야 하기 때문이다.

> 형변환은 인스턴스에 아무런 영향을 미치지 못하지만 인스턴스에서 사용할 수 있는 멤버의 범위를 조절할 수 있다.

다만 아래와 같은 상황은 컴파일은 될지라도 런타임오류가 발생한다.

````java
class Car{
    void drive(){}
}
class Bmw extends Car{
    void autoDrive(){}
}
class Ex{
  public static void main(String[] args) {
    Car car = new Car();
    Bmw bmw = (Bmw) car; // 컴파일 OK.. But 런타임 오류 발생
    
    car = new Bmw();
    bmw = (Bmw) car; // 다운캐스팅.. AND 문제 없음
  }
}
````

다운캐스팅에서 형변환을 적절하게 해주었더라도 결국 참조하고 있는 인스턴스 자체가 조상클래스이기 때문에
허용되지 않는다.


## instanceOf 연산자



# 6. 추상 클래스

## 추상 클래스란?

클래스를 속성과 기능으로 이루어진 설계도에 비유한다면, 추상 클래스는 미완성 설계도에 비유할 수 있다. 따라서
클래스와 다르게 인스턴스를 생성할 수 없으며 오직 상속을 통해 자손 클래스에서 완성될 수 있다.

추상클래스의 의의는 **미완성 설계도**를 기반으로 어느정도의 틀을 잡고 이를 상속하는 클래스들의
입맛에 맞게 설계도를 완성시킴에 있다.

추상클래스는 추상 메서드를 가지고 있으며 이를 나타내기 위해 abstract라는 키워드를 앞에 명시해주어야한다.
다른 부분은 클래스와 동일하게 생성자 및 멤버변수, 메서드 등도 가질 수 있다.

## 추상 메서드

메서드의 선언부만 작성하고 구현부를 작성하지 않고 남겨둔다. 즉, 동일한 목적을 가지지만
이를 수행하기 위해 방법(구현부)은 미완의 상태로 남겨주는 것이다.

따라서 상속 계층도를 따라 내려갈 수록 구체화의 정도가 심해지게 된다.

## 추상 클래스의 작성

예시
```java

abstract class Player{
    boolean pause;
    int currentPos;
    
    Player(){
        pause = false;
        currentPost;
    }
    
    abstract void play(int pos);
    abstract void stop();
    void play(){
        play(currentPos);
    }
}

class CDPlayer extends Player{
    void play(int currentPos){
      /**
       * 구현
        */   
    }
    void stop(){
      /**
       * 구현 
       */
    }
}

```

> 추상클래스를 상속받은 클래스에서는 반드시 추상메서드를 구현해야한다.

# 7. 인터페이스

## 인터페이스란?

인터페이스는 일종의 추상클래스로 추상클래스처럼 추상메서드를 갖지만 추상 클래스보다 추상화 정도가 높아서 추상클래스와 달리 몸통을 갖춘 일반 메서드 또는 멤버변수를 구성원으로 가질 수 없다. 오직 추상메서드와 상수만을 멤버로 가질 수 있으며 그 외의 어떠한 요소도 허용하지 않는다.

|추상클래스 | 인터페이스 |
|---|---|
|미완성 설계도|기본 설계도|

추상클래스는 부분적으로 완성된 미완성 설계도라고 한다면, 인터페이스는 밑그림만 그려져 있는 기본 설계도라고 할 수 있다.

그 자체만으로 사용되기 보다는 다른 클래스를 작성하는데 도움을 줄 목적으로 작성된다.

## 인터페이스의 작성

```java
interface 이름 {
	public static final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수목록);
}
```
다음과 같이 class 대신 interface 를 사용하며 접근제어자로 public 또는 default를 사용할 수 있다.

- 모든 멤버변수는 public static final 이어야하며, 이를 생략할 수 있다.
- 모든 메서드는 public abstract 이어야 하며, 이를 생략할 수 있다.
  (static 메서드와 디폴트 메서드는 예외 JDK 1.8 부터 지원)

인터페이스에 정의도니 모든 멤버에 예외없이 적용되는 사항이기 때문에 제어자를 생략할 수 있는 것이며, 편의상 생략하는 경우가 많다. 생략된 제어자는 컴파일러가 자동적으로 추가해준다.

예제

```java
interface{
	public statid final int NUM = 4;
    final int DIMOND = 3;
    static int HEART = 2;
    int CLOVER = 1;
    
    public abstract String getCardNumber();
    String getCardKind();
}
```

## 인터페이스의 상속

인터페이스는 인터페이스로부터만 상속을 받을 수 있으며, 클래스와 달리 다중 상속이 가능하다.

예제

```java

interface A{}

interface B{}

interface C extends A, B{}

```

클래스의 상속과 마찬가지로 조상에 정의된 멤버를 모두 상속받는다.


## 인터페이스의 구현

인터페이스도 추상클래스와 마찬가지로 그 자체로는 인스턴스를 생성할 수 없으며, 자신에 정의된 추상메서드의 몸통을 만들어주는 클래스를 작성해야하는데, implements 키워드를 사용해서 구현체를 만든다.

만일 구현하는 인터페이스의 메서드 중 일부만 구현다면 abstract 를 붙여 추상클래스로 선언해야한다.

```java
abstract class Fighter implements Fightable{
	public void move(int x, int y){
    	// 생략
    }
}
```

인터페이스의 장점

- 개발 시간 단축
- 표준화 가능
- 서로 관계없는 클래스들에게 관계를 맺어줄 수 있음
- 독립적인 프로그래밍 기능( 구현체 분리 - DIP ) 


# 8. 내부 클래스

내부 클래스는 클래스 내에 선언된다는 점을 제외하고 일반적인 클래스와 다르지않다.

두 클래스가 서로 긴밀한 관계에 있다면 한 클래스를 다른 클래스의 내부 클래스로 선언하여 두 클래스의 멤버들간에 서로를 쉽게 접근할 수 있다는
장점과 외부에는 불필요한 클래스를 감춤으로써 코드의 복잡성을 줄일 수 있다는 장점을 얻을 수 있다.



